import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../models/trip.dart';
import '../models/user.dart';
import '../models/app_error.dart';
import '../repositories/trip_repository.dart';
import '../repositories/firebase_trip_repository.dart';
import 'auth_provider.dart';

part 'trip_provider.g.dart';

/// Provider for the TripRepository instance
@riverpod
TripRepository tripRepository(Ref ref) {
  return FirebaseTripRepository();
}

/// Notifier for managing the list of user trips
@riverpod
class TripListNotifier extends _$TripListNotifier {
  @override
  Stream<List<Trip>> build() {
    final authState = ref.watch(authNotifierProvider);
    if (authState.isLoading) {
      return Stream.value(<Trip>[]);
    }
    if (authState.hasError) {
      final appError = _handleTripError(authState.error!);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      return Stream.value(<Trip>[]);
    }
    final user = authState.value;
    if (user == null) {
      return Stream.value(<Trip>[]);
    }
    final tripRepository = ref.watch(tripRepositoryProvider);
    return tripRepository.getUserTrips(user.id);
  }
  
  /// Create a new trip
  Future<void> createTrip({
    required String name,
    required int durationDays,
  }) async {
    try {
      final user = ref.read(authNotifierProvider).value;
      if (user == null) {
        throw Exception('User must be authenticated to create a trip');
      }
      
      final tripRepository = ref.read(tripRepositoryProvider);
      final now = DateTime.now();
      
      final newTrip = Trip(
        id: '', // Will be generated by repository
        name: name,
        durationDays: durationDays,
        ownerId: user.id,
        collaboratorIds: [],
        createdAt: now,
        updatedAt: now,
      );
      
      await tripRepository.createTrip(newTrip);
      // The stream will automatically update with the new trip
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Trip created successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Update an existing trip
  Future<void> updateTrip(Trip trip) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      final updatedTrip = trip.copyWith(updatedAt: DateTime.now());
      await tripRepository.updateTrip(updatedTrip);
      // The stream will automatically update with the changes
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Trip updated successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Delete a trip
  Future<void> deleteTrip(String tripId) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      await tripRepository.deleteTrip(tripId);
      // The stream will automatically update with the removal
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Trip deleted successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Add a collaborator to a trip
  Future<void> addCollaborator(String tripId, String email) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      await tripRepository.addCollaborator(tripId, email);
      // The stream will automatically update with the new collaborator
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Collaborator added successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Remove a collaborator from a trip
  Future<void> removeCollaborator(String tripId, String userId) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      await tripRepository.removeCollaborator(tripId, userId);
      // The stream will automatically update with the removal
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Collaborator removed successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Helper method to convert exceptions to AppError
  AppError _handleTripError(Object error) {
    final errorMessage = error.toString();
    
    if (errorMessage.contains('network')) {
      return const AppError.network('Network error while managing trips. Please check your connection.');
    } else if (errorMessage.contains('permission')) {
      return const AppError.permission('You do not have permission to perform this action.');
    } else if (errorMessage.contains('not found') && errorMessage.contains('Trip')) {
      return const AppError.validation('Trip not found or no longer exists.');
    } else if (errorMessage.contains('not found') && errorMessage.contains('need to sign up')) {
      // Handle user not found for collaboration
      return AppError.validation(errorMessage.replaceAll('Exception: ', ''));
    } else if (errorMessage.contains('already a collaborator')) {
      return const AppError.validation('This user is already a collaborator on this trip.');
    } else if (errorMessage.contains('already the owner')) {
      return const AppError.validation('This user is already the owner of this trip.');
    } else if (errorMessage.contains('Cannot remove the trip owner')) {
      return const AppError.validation('Cannot remove the trip owner from collaborators.');
    } else {
      return AppError.unknown('An error occurred while managing trips: ${errorMessage.replaceAll('Exception: ', '')}');
    }
  }
}

/// Provider for getting a single trip by ID
@riverpod
class TripDetailNotifier extends _$TripDetailNotifier {
  @override
  Future<Trip?> build(String tripId) async {
    try {
      final tripRepository = ref.watch(tripRepositoryProvider);
      final trip = await tripRepository.getTripById(tripId);
      if (trip == null) {
        const appError = AppError.validation('Trip not found or no longer exists.');
        ref.read(errorNotifierProvider.notifier).showError(appError);
        throw appError;
      }
      return trip;
    } catch (error) {
      const appError = AppError.unknown('Failed to load trip details.');
      ref.read(errorNotifierProvider.notifier).showError(appError);
      throw appError;
    }
  }
  
  /// Refresh the trip data
  Future<void> refresh() async {
    ref.invalidateSelf();
    await future;
  }
}

/// Provider for getting trip collaborators
@riverpod
class TripCollaboratorsNotifier extends _$TripCollaboratorsNotifier {
  @override
  Future<List<User>> build(String tripId) async {
    try {
      final tripRepository = ref.watch(tripRepositoryProvider);
      return await tripRepository.getTripCollaborators(tripId);
    } catch (error) {
      const appError = AppError.unknown('Failed to load trip collaborators.');
      ref.read(errorNotifierProvider.notifier).showError(appError);
      throw appError;
    }
  }
  
  /// Refresh the collaborators data
  Future<void> refresh() async {
    ref.invalidateSelf();
    await future;
  }
}