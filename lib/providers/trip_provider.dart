import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../models/trip.dart';
import '../models/app_error.dart';
import '../repositories/trip_repository.dart';
import '../repositories/mock_trip_repository.dart';
import 'auth_provider.dart';

part 'trip_provider.g.dart';

/// Provider for the TripRepository instance
@riverpod
TripRepository tripRepository(Ref ref) {
  return MockTripRepository();
}

/// Notifier for managing the list of user trips
@riverpod
class TripListNotifier extends _$TripListNotifier {
  @override
  Stream<List<Trip>> build() {
    // Listen to authentication state changes reactively
    return ref.watch(authNotifierProvider).when(
      data: (user) {
        if (user == null) {
          // Return empty stream if no user is authenticated
          return Stream.value(<Trip>[]);
        }
        // Watch tripRepositoryProvider so it updates if the repo changes
        final tripRepository = ref.watch(tripRepositoryProvider);
        // Return stream of trips for the authenticated user
        return tripRepository.getUserTrips(user.id);
      },
      loading: () => Stream.value(<Trip>[]),
      error: (error, stackTrace) {
        // Handle error by notifying global error handler
        final appError = _handleTripError(error);
        ref.read(errorNotifierProvider.notifier).showError(appError);
        return Stream.value(<Trip>[]);
      },
    );
  }
  
  /// Create a new trip
  Future<void> createTrip({
    required String name,
    required int durationDays,
  }) async {
    try {
      final user = ref.read(authNotifierProvider).value;
      if (user == null) {
        throw Exception('User must be authenticated to create a trip');
      }
      
      final tripRepository = ref.read(tripRepositoryProvider);
      final now = DateTime.now();
      
      final newTrip = Trip(
        id: '', // Will be generated by repository
        name: name,
        durationDays: durationDays,
        ownerId: user.id,
        collaboratorIds: [],
        createdAt: now,
        updatedAt: now,
      );
      
      await tripRepository.createTrip(newTrip);
      // The stream will automatically update with the new trip
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Trip created successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Update an existing trip
  Future<void> updateTrip(Trip trip) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      final updatedTrip = trip.copyWith(updatedAt: DateTime.now());
      await tripRepository.updateTrip(updatedTrip);
      // The stream will automatically update with the changes
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Trip updated successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Delete a trip
  Future<void> deleteTrip(String tripId) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      await tripRepository.deleteTrip(tripId);
      // The stream will automatically update with the removal
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Trip deleted successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Add a collaborator to a trip
  Future<void> addCollaborator(String tripId, String email) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      await tripRepository.addCollaborator(tripId, email);
      // The stream will automatically update with the new collaborator
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Collaborator added successfully!');
    } catch (error) {
      final appError = _handleTripError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Helper method to convert exceptions to AppError
  AppError _handleTripError(Object error) {
    if (error.toString().contains('network')) {
      return const AppError.network('Network error while managing trips. Please check your connection.');
    } else if (error.toString().contains('permission')) {
      return const AppError.permission('You do not have permission to perform this action.');
    } else if (error.toString().contains('not found')) {
      return const AppError.validation('Trip not found or no longer exists.');
    } else {
      return const AppError.unknown('An error occurred while managing trips. Please try again.');
    }
  }
}

/// Provider for getting a single trip by ID
@riverpod
class TripDetailNotifier extends _$TripDetailNotifier {
  @override
  Future<Trip?> build(String tripId) async {
    try {
      final tripRepository = ref.read(tripRepositoryProvider);
      return await tripRepository.getTripById(tripId);
    } catch (error) {
      final appError = const AppError.unknown('Failed to load trip details.');
      ref.read(errorNotifierProvider.notifier).showError(appError);
      throw appError;
    }
  }
  
  /// Refresh the trip data
  Future<void> refresh() async {
    ref.invalidateSelf();
    await future;
  }
}