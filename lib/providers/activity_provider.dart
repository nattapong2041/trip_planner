import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../models/activity.dart';
import '../models/brainstorm_idea.dart';
import '../models/app_error.dart';
import '../repositories/activity_repository.dart';
import '../repositories/firebase_activity_repository.dart';
import 'auth_provider.dart';

part 'activity_provider.g.dart';

/// Provider for the ActivityRepository instance
@riverpod
ActivityRepository activityRepository(Ref ref) {
  return FirebaseActivityRepository();
}

/// Notifier for managing activities for a specific trip
@riverpod
class ActivityListNotifier extends _$ActivityListNotifier {
  @override
  Stream<List<Activity>> build(String tripId) {
    final activityRepository = ref.watch(activityRepositoryProvider);
    return activityRepository.getTripActivities(tripId).handleError((error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
    });
  }
  
  /// Create a new activity
  Future<void> createActivity({
    required String tripId,
    required String place,
    required String activityType,
    String? price,
    String? notes,
  }) async {
    try {
      final user = ref.read(authNotifierProvider).value;
      if (user == null) {
        throw Exception('User must be authenticated to create an activity');
      }
      
      final activityRepository = ref.read(activityRepositoryProvider);
      final now = DateTime.now();
      
      final newActivity = Activity(
        id: '', // Will be generated by repository
        tripId: tripId,
        place: place,
        activityType: activityType,
        price: price,
        notes: notes,
        assignedDay: null, // Starts in activity pool
        dayOrder: null,
        createdBy: user.id,
        createdAt: now,
        brainstormIdeas: [],
      );
      
      await activityRepository.createActivity(newActivity);
      // The stream will automatically update with the new activity
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Activity created successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Update an existing activity
  Future<void> updateActivity(Activity activity) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      await activityRepository.updateActivity(activity);
      // The stream will automatically update with the changes
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Activity updated successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Delete an activity
  Future<void> deleteActivity(String activityId) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      await activityRepository.deleteActivity(activityId);
      // The stream will automatically update with the removal
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Activity deleted successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Assign an activity to a specific day with optional time slot
  Future<void> assignActivityToDay(String activityId, String day, int dayOrder, {String? timeSlot}) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      final activity = await activityRepository.getActivityById(activityId);
      
      if (activity == null) {
        throw Exception('Activity not found');
      }
      
      final updatedActivity = activity.copyWith(
        assignedDay: day,
        dayOrder: dayOrder,
        timeSlot: timeSlot,
      );
      
      await activityRepository.updateActivity(updatedActivity);
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Activity assigned to day successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Move an activity back to the activity pool (unassign from day)
  Future<void> moveActivityToPool(String activityId) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      final activity = await activityRepository.getActivityById(activityId);
      
      if (activity == null) {
        throw Exception('Activity not found');
      }
      
      final updatedActivity = activity.copyWith(
        assignedDay: null,
        dayOrder: null,
        timeSlot: null, // Clear time slot when moving to pool
      );
      
      await activityRepository.updateActivity(updatedActivity);
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Activity moved to pool successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Reorder activities within a day with automatic time slot updates
  Future<void> reorderActivitiesInDay(String day, List<Activity> reorderedActivities) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      
      // Separate timed and untimed activities
      final timedActivities = reorderedActivities.where((a) => a.timeSlot != null).toList();
      final untimedActivities = reorderedActivities.where((a) => a.timeSlot == null).toList();
      
      // Sort timed activities by their time slots
      timedActivities.sort((a, b) {
        if (a.timeSlot == null || b.timeSlot == null) return 0;
        return a.timeSlot!.compareTo(b.timeSlot!);
      });
      
      // Combine: timed activities first (in chronological order), then untimed
      final finalOrder = [...timedActivities, ...untimedActivities];
      
      // Update each activity with its new order
      for (int i = 0; i < finalOrder.length; i++) {
        final activity = finalOrder[i];
        final updatedActivity = activity.copyWith(
          assignedDay: day,
          dayOrder: i,
        );
        await activityRepository.updateActivity(updatedActivity);
      }
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Activities reordered successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Update an activity's time slot and automatically reorder activities in the day
  Future<void> updateActivityTimeSlot(String activityId, String? timeSlot) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      final activity = await activityRepository.getActivityById(activityId);
      
      if (activity == null) {
        throw Exception('Activity not found');
      }
      
      // Update the activity with the new time slot
      final updatedActivity = activity.copyWith(timeSlot: timeSlot);
      await activityRepository.updateActivity(updatedActivity);
      
      // If the activity is assigned to a day, reorder activities in that day
      if (activity.assignedDay != null) {
        final allActivities = await future;
        final dayActivities = allActivities
            .where((a) => a.assignedDay == activity.assignedDay)
            .map((a) => a.id == activityId ? updatedActivity : a)
            .toList();
        
        await reorderActivitiesInDay(activity.assignedDay!, dayActivities);
      }
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Time slot updated successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Move activity from one day to another with specific order
  Future<void> moveActivityBetweenDays(String activityId, String? fromDay, String toDay, int newOrder) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      final activity = await activityRepository.getActivityById(activityId);
      
      if (activity == null) {
        throw Exception('Activity not found');
      }
      
      // Update the moved activity
      final updatedActivity = activity.copyWith(
        assignedDay: toDay,
        dayOrder: newOrder,
      );
      
      await activityRepository.updateActivity(updatedActivity);
      
      // If moving from a day (not from pool), reorder remaining activities in the source day
      if (fromDay != null) {
        final allActivities = await future;
        // Get all activities for the source day
        final remainingActivities = allActivities
            .where((a) => a.assignedDay == fromDay && a.id != activityId)
            .toList()
          ..sort((a, b) => (a.dayOrder ?? 0).compareTo(b.dayOrder ?? 0));
        
        // Reorder remaining activities to fill the gap
        for (int i = 0; i < remainingActivities.length; i++) {
          final activityToUpdate = remainingActivities[i];
          if (activityToUpdate.dayOrder != i) {
            final reorderedActivity = activityToUpdate.copyWith(dayOrder: i);
            await activityRepository.updateActivity(reorderedActivity);
          }
        }
      }
      
      // Reorder activities in the destination day to make room
      final allActivities = await future;
      final destinationActivities = allActivities
          .where((a) => a.assignedDay == toDay && a.id != activityId)
          .toList()
        ..sort((a, b) => (a.dayOrder ?? 0).compareTo(b.dayOrder ?? 0));
      
      // Shift activities at and after the new position
      for (int i = newOrder; i < destinationActivities.length; i++) {
        final activityToUpdate = destinationActivities[i];
        final reorderedActivity = activityToUpdate.copyWith(dayOrder: i + 1);
        await activityRepository.updateActivity(reorderedActivity);
      }
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Activity moved successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Add a brainstorm idea to an activity
  Future<void> addBrainstormIdea(String activityId, String description) async {
    try {
      final user = ref.read(authNotifierProvider).value;
      if (user == null) {
        throw Exception('User must be authenticated to add brainstorm ideas');
      }
      
      final activityRepository = ref.read(activityRepositoryProvider);
      final brainstormIdea = BrainstormIdea(
        id: '', // Will be generated by repository
        description: description,
        createdBy: user.id,
        createdAt: DateTime.now(),
      );
      
      await activityRepository.addBrainstormIdea(activityId, brainstormIdea);
      // The stream will automatically update with the new brainstorm idea
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Brainstorm idea added successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Remove a brainstorm idea from an activity
  Future<void> removeBrainstormIdea(String activityId, String ideaId) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      await activityRepository.removeBrainstormIdea(activityId, ideaId);
      // The stream will automatically update with the removal
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Brainstorm idea removed successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Reorder brainstorm ideas within an activity for real-time collaboration
  Future<void> reorderBrainstormIdeas(String activityId, List<String> ideaIds) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      await activityRepository.reorderBrainstormIdeas(activityId, ideaIds);
      // The stream will automatically update with the new order
      
      // Show success message
      ref.read(successNotifierProvider.notifier).showSuccessWithAutoClear('Brainstorm ideas reordered successfully!');
    } catch (error) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Helper method to convert exceptions to AppError
  AppError _handleActivityError(Object error) {
    if (error.toString().contains('network')) {
      return const AppError.network('Network error while managing activities. Please check your connection.');
    } else if (error.toString().contains('permission')) {
      return const AppError.permission('You do not have permission to perform this action.');
    } else if (error.toString().contains('not found')) {
      return const AppError.validation('Activity not found or no longer exists.');
    } else {
      return const AppError.unknown('An error occurred while managing activities. Please try again.');
    }
  }
}

/// Provider for getting a single activity by ID
@riverpod
class ActivityDetailNotifier extends _$ActivityDetailNotifier {
  @override
  Future<Activity?> build(String activityId) async {
    try {
      final activityRepository = ref.watch(activityRepositoryProvider);
      return await activityRepository.getActivityById(activityId);
    } catch (error) {
      final appError = const AppError.unknown('Failed to load activity details.');
      ref.read(errorNotifierProvider.notifier).showError(appError);
      throw appError;
    }
  }
  
  /// Refresh the activity data
  Future<void> refresh() async {
    ref.invalidateSelf();
    await future;
  }
}

/// Provider for getting activities grouped by assignment status
@riverpod
class ActivityGroupsNotifier extends _$ActivityGroupsNotifier {
  @override
  Future<ActivityGroups> build(String tripId) async {
    final activities = await ref.watch(activityListNotifierProvider(tripId).future);
    
    final poolActivities = <Activity>[];
    final assignedActivities = <String, List<Activity>>{};
    
    for (final activity in activities) {
      if (activity.assignedDay == null) {
        poolActivities.add(activity);
      } else {
        final day = activity.assignedDay!;
        if (!assignedActivities.containsKey(day)) {
          assignedActivities[day] = [];
        }
        assignedActivities[day]!.add(activity);
      }
    }
    
    // Sort activities within each day by dayOrder
    for (final dayActivities in assignedActivities.values) {
      dayActivities.sort((a, b) => (a.dayOrder ?? 0).compareTo(b.dayOrder ?? 0));
    }
    
    return ActivityGroups(
      poolActivities: poolActivities,
      assignedActivities: assignedActivities,
    );
  }
}

/// Data class for grouped activities
class ActivityGroups {
  final List<Activity> poolActivities;
  final Map<String, List<Activity>> assignedActivities;
  
  const ActivityGroups({
    required this.poolActivities,
    required this.assignedActivities,
  });
}