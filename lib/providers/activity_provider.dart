import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../models/activity.dart';
import '../models/brainstorm_idea.dart';
import '../models/app_error.dart';
import '../repositories/activity_repository.dart';
import '../repositories/mock_activity_repository.dart';
import 'auth_provider.dart';

part 'activity_provider.g.dart';

/// Provider for the ActivityRepository instance
@riverpod
ActivityRepository activityRepository(Ref ref) {
  return MockActivityRepository();
}

/// Notifier for managing activities for a specific trip
@riverpod
class ActivityListNotifier extends _$ActivityListNotifier {
  @override
  Stream<List<Activity>> build(String tripId) {
    final activityRepository = ref.read(activityRepositoryProvider);
    return activityRepository.getTripActivities(tripId).handleError((error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
    });
  }
  
  /// Create a new activity
  Future<void> createActivity({
    required String tripId,
    required String place,
    required String activityType,
    String? price,
    String? notes,
  }) async {
    try {
      final user = ref.read(authNotifierProvider).value;
      if (user == null) {
        throw Exception('User must be authenticated to create an activity');
      }
      
      final activityRepository = ref.read(activityRepositoryProvider);
      final now = DateTime.now();
      
      final newActivity = Activity(
        id: '', // Will be generated by repository
        tripId: tripId,
        place: place,
        activityType: activityType,
        price: price,
        notes: notes,
        assignedDay: null, // Starts in activity pool
        dayOrder: null,
        createdBy: user.id,
        createdAt: now,
        brainstormIdeas: [],
      );
      
      await activityRepository.createActivity(newActivity);
      // The stream will automatically update with the new activity
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Update an existing activity
  Future<void> updateActivity(Activity activity) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      await activityRepository.updateActivity(activity);
      // The stream will automatically update with the changes
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Delete an activity
  Future<void> deleteActivity(String activityId) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      await activityRepository.deleteActivity(activityId);
      // The stream will automatically update with the removal
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Assign an activity to a specific day
  Future<void> assignActivityToDay(String activityId, String day, int dayOrder) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      final activity = await activityRepository.getActivityById(activityId);
      
      if (activity == null) {
        throw Exception('Activity not found');
      }
      
      final updatedActivity = activity.copyWith(
        assignedDay: day,
        dayOrder: dayOrder,
      );
      
      await activityRepository.updateActivity(updatedActivity);
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Move an activity back to the activity pool (unassign from day)
  Future<void> moveActivityToPool(String activityId) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      final activity = await activityRepository.getActivityById(activityId);
      
      if (activity == null) {
        throw Exception('Activity not found');
      }
      
      final updatedActivity = activity.copyWith(
        assignedDay: null,
        dayOrder: null,
      );
      
      await activityRepository.updateActivity(updatedActivity);
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Reorder activities within a day
  Future<void> reorderActivitiesInDay(String day, List<Activity> reorderedActivities) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      
      // Update each activity with its new order
      for (int i = 0; i < reorderedActivities.length; i++) {
        final activity = reorderedActivities[i];
        final updatedActivity = activity.copyWith(
          assignedDay: day,
          dayOrder: i,
        );
        await activityRepository.updateActivity(updatedActivity);
      }
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Move activity from one day to another with specific order
  Future<void> moveActivityBetweenDays(String activityId, String? fromDay, String toDay, int newOrder) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      final activity = await activityRepository.getActivityById(activityId);
      
      if (activity == null) {
        throw Exception('Activity not found');
      }
      
      // Update the moved activity
      final updatedActivity = activity.copyWith(
        assignedDay: toDay,
        dayOrder: newOrder,
      );
      
      await activityRepository.updateActivity(updatedActivity);
      
      // If moving from a day (not from pool), reorder remaining activities in the source day
      if (fromDay != null) {
        final allActivities = await ref.read(activityListNotifierProvider(activity.tripId).future);
        final remainingActivities = allActivities
            .where((a) => a.assignedDay == fromDay && a.id != activityId)
            .toList()
          ..sort((a, b) => (a.dayOrder ?? 0).compareTo(b.dayOrder ?? 0));
        
        // Reorder remaining activities to fill the gap
        for (int i = 0; i < remainingActivities.length; i++) {
          final activityToUpdate = remainingActivities[i];
          if (activityToUpdate.dayOrder != i) {
            final reorderedActivity = activityToUpdate.copyWith(dayOrder: i);
            await activityRepository.updateActivity(reorderedActivity);
          }
        }
      }
      
      // Reorder activities in the destination day to make room
      final allActivities = await ref.read(activityListNotifierProvider(activity.tripId).future);
      final destinationActivities = allActivities
          .where((a) => a.assignedDay == toDay && a.id != activityId)
          .toList()
        ..sort((a, b) => (a.dayOrder ?? 0).compareTo(b.dayOrder ?? 0));
      
      // Shift activities at and after the new position
      for (int i = newOrder; i < destinationActivities.length; i++) {
        final activityToUpdate = destinationActivities[i];
        final reorderedActivity = activityToUpdate.copyWith(dayOrder: i + 1);
        await activityRepository.updateActivity(reorderedActivity);
      }
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Add a brainstorm idea to an activity
  Future<void> addBrainstormIdea(String activityId, String description) async {
    try {
      final user = ref.read(authNotifierProvider).value;
      if (user == null) {
        throw Exception('User must be authenticated to add brainstorm ideas');
      }
      
      final activityRepository = ref.read(activityRepositoryProvider);
      final brainstormIdea = BrainstormIdea(
        id: '', // Will be generated by repository
        description: description,
        createdBy: user.id,
        createdAt: DateTime.now(),
      );
      
      await activityRepository.addBrainstormIdea(activityId, brainstormIdea);
      // The stream will automatically update with the new brainstorm idea
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Remove a brainstorm idea from an activity
  Future<void> removeBrainstormIdea(String activityId, String ideaId) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      await activityRepository.removeBrainstormIdea(activityId, ideaId);
      // The stream will automatically update with the removal
    } catch (error, stackTrace) {
      final appError = _handleActivityError(error);
      ref.read(errorNotifierProvider.notifier).showError(appError);
      rethrow;
    }
  }
  
  /// Helper method to convert exceptions to AppError
  AppError _handleActivityError(Object error) {
    if (error.toString().contains('network')) {
      return AppError.network('Network error while managing activities. Please check your connection.');
    } else if (error.toString().contains('permission')) {
      return AppError.permission('You do not have permission to perform this action.');
    } else if (error.toString().contains('not found')) {
      return AppError.validation('Activity not found or no longer exists.');
    } else {
      return AppError.unknown('An error occurred while managing activities. Please try again.');
    }
  }
}

/// Provider for getting a single activity by ID
@riverpod
class ActivityDetailNotifier extends _$ActivityDetailNotifier {
  @override
  Future<Activity?> build(String activityId) async {
    try {
      final activityRepository = ref.read(activityRepositoryProvider);
      return await activityRepository.getActivityById(activityId);
    } catch (error, stackTrace) {
      final appError = AppError.unknown('Failed to load activity details.');
      ref.read(errorNotifierProvider.notifier).showError(appError);
      throw appError;
    }
  }
  
  /// Refresh the activity data
  Future<void> refresh() async {
    ref.invalidateSelf();
    await future;
  }
}

/// Provider for getting activities grouped by assignment status
@riverpod
class ActivityGroupsNotifier extends _$ActivityGroupsNotifier {
  @override
  Future<ActivityGroups> build(String tripId) async {
    final activities = await ref.watch(activityListNotifierProvider(tripId).future);
    
    final poolActivities = <Activity>[];
    final assignedActivities = <String, List<Activity>>{};
    
    for (final activity in activities) {
      if (activity.assignedDay == null) {
        poolActivities.add(activity);
      } else {
        final day = activity.assignedDay!;
        if (!assignedActivities.containsKey(day)) {
          assignedActivities[day] = [];
        }
        assignedActivities[day]!.add(activity);
      }
    }
    
    // Sort activities within each day by dayOrder
    for (final dayActivities in assignedActivities.values) {
      dayActivities.sort((a, b) => (a.dayOrder ?? 0).compareTo(b.dayOrder ?? 0));
    }
    
    return ActivityGroups(
      poolActivities: poolActivities,
      assignedActivities: assignedActivities,
    );
  }
}

/// Data class for grouped activities
class ActivityGroups {
  final List<Activity> poolActivities;
  final Map<String, List<Activity>> assignedActivities;
  
  const ActivityGroups({
    required this.poolActivities,
    required this.assignedActivities,
  });
}